#!/usr/bin/env nextflow
nextflow.enable.dsl = 2

date=new Date().format( 'yyMMdd' )
user="$USER"
runID="${date}.${user}"




params.server                           =null
params.outdir                           ='tumorBoardWGS_results'
params.rundir                           ="${launchDir.baseName}" 
params.genome                           ="hg38" //default assembly is hg38, unless --genome is set!
params.rsem_strand                      ="reverse" // TO DO: INCLUDE STRANDEDNESS SELECTION!!!
params.gatk                             =null
params.suffix                           ="WG4_NGC"
// Unset parameters:
params.help                             =false
params.data                             =null
params.fastq                            =null
params.fastqInput                       =null
params.hg38v1                           =null
params.hg38v2                           =null
params.wes                              =null
// edit analysis steps
params.default                          =null
params.skipSplicing                     =null
params.skipFusion                       =null
params.skipExpression                   =null
params.skipVariants                     =null
params.skipTrim                         =null
params.skipQC                           =null
params.skipDNA                          =null
params.skipRNA                          =null
params.keepwork                         =null
params.nomail                           =null
params.skipSequenza                     =null
params.skipStandard                     =null
params.skipWGS                          =null
// skip or include individual analysis - unset parameters:
params.dupradar                         =null   // not run by default
params.qualimap                         =null   // not run by default
params.picard                           =null   // not run by default   

params.dataArchive                      ="/lnx01_data2/shared/dataArchive/"

def helpMessage() {
    log.info"""

    Generel info:
    Requires a samplesheet containing 5 columns in specific order (tab separated), without headerline:
    1) caseID, 2) NPN normal DNA, 3) NPN tumor DNA, 4) NPN tumor RNA, 5) PCGR tumor value

    Example samplesheet:

    johnDoe 112217976652	111184925465	111184925473    23

    The script will automatically look for inputdata (CRAM files for DNA data and fastq files for RNA-seq) at KG Vejle data archive.

    The user can point to a specific folder containing raw data (FastQ) using the --fastq option 
    This is only needed if input data only exists outside the data archive (e.g. if data are in personal folders).


    Main options:
      --help                print this help message

      --outdir              Select which folder to write output to.
                                Default: caseID from samplesheet

      --samplesheet         path to case samplesheet. Can contain multiple patients/cases (each case in a separate line). 

      --server              Select which server the analysis is performed on (lnx01 or other)
                                Default: null (only set this option if using lnx01 - defaults to all other servers)

      --fastq               Path to dir with fastq files
                                Default: data storage dirs KG Vejle archive

      --keepwork            keep the workfolder generated by the nextflow script.
                                Default: not set - removes the Work folder

      --nomail              Does not send a mail-message when completing a script
                                Default: not set - sends mail message if the user is mmaj or raspau and only if the script has been running longer than 20 minutes.


    QC options:
      --skipQC              Skip all QC steps except MultiQC
      --qualimap            Run qualimap BAMQC
                                Default: Do not run BAMQC (timeconsuming!)
      --dupradar            Run Dupradar (not available this version of the script)
                                Default: Do not run Dupradar (timeconsuming!)

    Analysis selection options (not set by default):
      --skipDNA             Do not run DNA analysis (only RNA)
      --skipRNA             Do not run RNA analysis (only DNA)  
      --skipWGS             Do not run analyses that require WGS data (e.g. HRD)
      --skipFusion          Do not call Fusions
      --skipAltSplicing     Do not call alternative splicevariants (e.g. exon skipping)
      --skipExpression      Do not analyse geneexpression (i.e. skip RSEM and isofox)

    """.stripIndent()
}
if (params.help) exit 0, helpMessage()


/*
switch (params.gatk) {

    case 'danak':
    gatk_image="gatk419.sif";
    break;
    case 'new':
    gatk_image="gatk4400.sif";
    break;
    case 'latest':
    gatk_image="gatk4500.sif";
    default:
    gatk_image="gatk4400.sif";
    break;
}


switch (params.server) {
    case 'lnx01':
        s_bind="/data/:/data/,/lnx01_data2/:/lnx01_data2/";
        simgpath="/data/shared/programmer/simg";
        params.intervals_list="/data/shared/genomes/hg38/interval.files/WGS_splitIntervals/wgs_splitinterval_BWI_subdivision3/*.interval_list";
        tmpDIR="/data/TMP/TMP.${user}/";
        gatk_exec="singularity run -B ${s_bind} ${simgpath}/${gatk_image} gatk";
        multiqc_config="/data/shared/programmer/configfiles/multiqc_config.yaml"
    break;
    default:
        s_bind="/data/:/data/,/lnx01_data2/:/lnx01_data2/,/fast/:/fast/,/lnx01_data3/:/lnx01_data3/,/lnx01_data4/:/lnx01_data4/";
        simgpath="/data/shared/programmer/simg";
        params.intervals_list="/data/shared/genomes/hg38/interval.files/WGS_splitIntervals/wgs_splitinterval_BWI_subdivision3/*.interval_list";
        tmpDIR="/fast/TMP/TMP.${user}/";
        gatk_exec="singularity run -B ${s_bind} ${simgpath}/${gatk_image} gatk";
        multiqc_config="/data/shared/programmer/configfiles/multiqc_config.yaml"
    break;
}

switch (params.genome) {
    case 'hg19':
        assembly="hg19"
        // Genome assembly files:
        genome_fasta = "/data/shared/genomes/hg19/human_g1k_v37.fasta"
        genome_fasta_fai = "/data/shared/genomes/hg19/human_g1k_v37.fasta.fai"
        genome_fasta_dict = "/data/shared/genomes/hg19/human_g1k_v37.dict"
        genome_version="V1"
        break;


    case 'hg38':
        assembly="hg38"
        smncaller_assembly="38"
        pcgr_assembly="grch38"
        // Genome assembly files:
        if (params.hg38v1) {
            genome_fasta = "/data/shared/genomes/hg38/GRCh38.primary.fa"
            genome_fasta_fai = "/data/shared/genomes/hg38/GRCh38.primary.fa.fai"
            genome_fasta_dict = "/data/shared/genomes/hg38/GRCh38.primary.dict"
            genome_version="hg38v1"
            cnvkit_germline_reference_PON="/data/shared/genomes/hg38/inhouse_DBs/hg38v1_primary/cnvkit/wgs_germline_PON/jgmr_45samples.reference.cnn"
            cnvkit_inhouse_cnn_dir="/data/shared/genomes/hg38/inhouse_DBs/hg38v1_primary/cnvkit/wgs_persample_cnn/"
            inhouse_SV="/data/shared/genomes/hg38/inhouse_DBs/hg38v1_primary/"
        }
        
        if (params.hg38v2){
            genome_fasta = "/data/shared/genomes/hg38/ucsc.hg38.NGS.analysisSet.fa"
            genome_fasta_fai = "/data/shared/genomes/hg38/ucsc.hg38.NGS.analysisSet.fa.fai"
            genome_fasta_dict = "/data/shared/genomes/hg38/ucsc.hg38.NGS.analysisSet.dict"
            genome_version="hg38v2"
        }

        // Current hg38 version (v3): NGC with masks and decoys.
        if (!params.hg38v2 && !params.hg38v1){
        genome_fasta = "/data/shared/genomes/hg38/GRCh38_masked_v2_decoy_exclude.fa"
        genome_fasta_fai = "/data/shared/genomes/hg38/GRCh38_masked_v2_decoy_exclude.fa.fai"
        genome_fasta_dict = "/data/shared/genomes/hg38/GRCh38_masked_v2_decoy_exclude.dict"
        genome_version="hg38v3"
        cnvkit_germline_reference_PON="/data/shared/genomes/hg38/inhouse_DBs/hg38v3_primary/cnvkit/hg38v3_109samples.cnvkit.reference.cnn"
        cnvkit_inhouse_cnn_dir="/data/shared/genomes/hg38/inhouse_DBs/hg38v3_primary/cnvkit/wgs_persample_cnn/"
        inhouse_SV="/data/shared//genomes/hg38/inhouse_DBs/hg38v3_primary/"
        }

        // Program files and resources:
        msisensor_list="/data/shared/genomes/hg38/program_DBs/msisensor/hg38v3_msisensor_scan.txt"
     
        gatk_wgs_pon="/data/shared/genomes/hg38/program_DBs/GATK/somatic/somatic-hg38_1000g_pon.hg38.vcf.gz"
        mutect_gnomad="/data/shared/genomes/hg38/program_DBs/GATK/somatic/somatic-hg38_af-only-gnomad.hg38.vcf.gz"
        gatk_contamination_ref="/data/shared/genomes/hg38/program_DBs/GATK/somatic/somatic-hg38_small_exac_common_3.hg38.vcf.gz"

        pcgr_data_dir="/data/shared/genomes/hg38/program_DBs/PCGR/"
        pcgr_VEP="/data/shared/genomes/hg38/program_DBs/PCGRv2/VEP_112_GRCh38_merged/"
        pcgr_data_dir3="/data/shared/genomes/hg38/program_DBs/PCGRv2/20240927/"
        hmftools_data_dir_v534="/data/shared/genomes/hg38/program_DBs/hmftools/v5_34/ref/38"
        hmftools_data_dir_v60="/data/shared/genomes/hg38/program_DBs/hmftools/v6_0/ref/38"
        sequenza_cg50_wig="/data/shared/genomes/hg38/program_DBs/sequenza/GRCh38.primary.cg50.sequenza.wig.gz"

        // Regions & variants:
        qualimap_ROI="/data/shared/genomes/hg38/interval.files/210129.hg38.gencode36.codingexons.20bp.SM.6col.bed"
        gencode_exons_ROI="/data/shared/genomes/hg38/interval.files/210129.hg38.gencode36.codingexons.SM.bed"

        ROI="/data/shared/genomes/hg38/interval.files/exome.ROIs/211130.hg38.refseq.gencode.fullexons.50bp.SM.bed"
        
        inhouse127_geneIntervals="/data/shared/genomes/hg38/interval.files/geneIntervals/241022_inhouse127genes.3col.SM.bed"


        callable_regions="/data/shared/genomes/hg38/interval.files/GATK.hg38.callable.regions.bed"
        manta_callable_regions="/data/shared/genomes/hg38/interval.files/manta/GATK.hg38.callable.regions.bed.gz"

        break;
}


outputDir="TN_WGS_results"
*/
///////////////////////// SAMPLESHEET CHANNELS /////////////////////

// Samplesheet cols (fixed order)
// 0: CaseID, 1: WES.blood, 2: WES.tumor, 3: RNA tumor, 4: pcgr_tumor_code

////////////////////////////////////////////////////////////////////////////////


/* To do:
 - cram symlinks fuull samplename so varseq recognizes the sample
 - purple segments rename to meta.id
 - purple output to tumorboradfiles folder.

*/




//////////// DEFAULT INPUT ///////////////////////

if (params.default) {
    inputFastq="${params.dataArchive}/lnx02/fastqStorage/novaRuns/**/*R{1,2}{_,.,-}*{fq,fastq}.gz";
    inputCram="${params.dataArchive}/lnx02/alignedData/hg38/novaRuns/**/*.cram"
    inputCrai="${params.dataArchive}/lnx02/alignedData/hg38/novaRuns/**/*.crai"
  //  inputFastq="/fast/data/tbtest/fastq/*.fastq.gz"
  //  inputCram="/fast/data/tbtest/cram/*.cram"
  //  inputCrai="/fast/data/tbtest/cram/*.crai"

    Channel.fromPath(inputCram, followLinks: true)
    |map { tuple(it.baseName,it) }
    |map {id,cram -> 
            (npn,datatype) =id.tokenize("_")
            meta=[npn:npn,datatype:datatype]
            [meta,cram]        
        }
    | set {cram_input }

    Channel.fromPath(inputCrai, followLinks: true)
    | map { tuple(it.baseName,it) }
    |map {id,crai -> 
            (npn,datatype) =id.tokenize("_")
            meta=[npn:npn,datatype:datatype]
             [meta,crai]         
        }
    |set {crai_input }

    cram_input.join(crai_input)
    |map { meta,cram,crai -> [meta.npn,meta,[cram,crai]] }
    | set {cram_final}

}

if (params.fastq) {
     inputFastq="${params.fastq}/*R{1,2}{_,.,-}*{fq,fastq}.gz";

}

if (!params.fastq) {
     inputFastq="${params.dataArchive}/**/*R{1,2}{_,.,-}*{fq,fastq}.gz";

}

if (params.fastq || params.fastqInput||params.default) {

    Channel.fromFilePairs(inputFastq, checkIfExists: true)
    | map { id, reads -> 
        (sample, ngstype)   = reads[0].baseName.tokenize("-")
       // (panel,subpanel)    = ngstype.tokenize("_")
        meta = [id:sample+"_"+ngstype, npn:sample, panel:ngstype]
        [meta.npn,meta, reads]
    }   
    | set {readsInput}

}

if (params.samplesheet) {
    channel.fromPath(params.samplesheet)
    | splitCsv(sep:'\t')
    |map { row -> 
            (caseID, npnNormal, npnTumorDNA, npnTumorRNA, pcgr) =tuple(row)
            //(normalID) =row[1]
        meta=[id:caseID,npnNormal:npnNormal,npnTumorDNA:npnTumorDNA,npnTumorRNA:npnTumorRNA,pcgr:pcgr]
        meta
        }
    | set {samplesheet_full}

    samplesheet_full
    | map { row -> 
            meta2=[row.npnNormal, row]}
        | set {samplesheetNormal}

    samplesheet_full
    | map { row -> 
            meta3=[row.npnTumorDNA, row]}
    | set {samplesheetTumorDNA}

    samplesheet_full
    | map { row -> 
            meta4=[row.npnTumorRNA, row]}
    | set {samplesheetTumorRNA}
}

if (params.samplesheet && (params.fastq||params.fastqInput)) {

    samplesheetNormal.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {normalDNA}

    samplesheetTumorDNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {tumorDNA}

    samplesheetTumorRNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {rnaInputFASTQ}

    normalDNA.concat(tumorDNA)
    |set {dnaInputFASTQ}    //meta, [fq1, fq2] pr sample
}

if (params.samplesheet && params.default) {


    samplesheetNormal.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {normalDNA}

    samplesheetTumorDNA.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }

    | set {tumorDNA}

    samplesheetTumorRNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {rnaInputFASTQ}

    normalDNA.join(tumorDNA)
    | map {meta,readsNormal,readsTumorDNA ->[meta,readsNormal+readsTumorDNA]}
    | set {dnaInputCRAM}
    //above meta: [id,npnNormal,npnTumorDNA, npnTumorRNA,pcgr]

    //per sample channels:
    samplesheetNormal.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaReads+[sampletype:"normal",id:metaSS.id],reads] }  // metaReads [npn, datatype (eg.WG4)]
    | set {normalDNA_single}

    samplesheetTumorDNA.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaReads+[sampletype:"tumor",id:metaSS.id],reads] }
    //[meta,reads]
    | set {tumorDNA_single}

    normalDNA_single.concat(tumorDNA_single)
    | set {dnaInputCRAM_single}
   // dnaInputCRAM_single.view() 
   // per sample (CRAM) ch: meta=[npn,datatype,sampletype,id] data=[cram,crai]


}

/*
include {inputFiles_symlinks_cram;
        inputFiles_symlinks_fastq;
        pcgr_v212_mutect2
        } from "./modules/dnaModules.nf" 


include {DNA_STANDARD;
         DNA_WGS
         } from "./subworkflows/dnaSubworkflows.nf" 


include {RNA_PREPROCESS;
         RNA_EXPRESSION;
         RNA_SPLICING;
         RNA_FUSION;
         RNA_QC
        } from "./subworkflows/rnaSubworkflows.nf" 
*/

include {inputFiles_symlinks_cram;
        inputFiles_symlinks_fastq;
        multiQC_ALL;
        pcgr_v212_mutect2 } from "./modules/dnaModules.nf" 


include { isofox } from "./modules/rnaModules.nf" 

include {DNA_PREPROCESS;
         DNA_STANDARD;
         DNA_WGS;
         DNA_QC;
         RNA_PREPROCESS;
         RNA_EXPRESSION;
         RNA_SPLICING;
         RNA_FUSION;
         RNA_QC } from "./subworkflows/mainSubworkflows.nf" 



workflow {
     /*
         */
    if (!params.skipDNA) {
        if(params.default) {
            inputFiles_symlinks_cram(dnaInputCRAM)
            // inputFiles_symlinks_fastq(rnaInputFASTQ)
        }
        if (params.fastq || params.fastqInput) {
            DNA_PREPROCESS(dnaInputFASTQ)
            DNA_PREPROCESS.out.finalAln //meta, cram, crai 
            |groupTuple
            |map {meta,cram,crai -> tuple(meta,[cram,crai])}
            |set {dnaInputCRAM}

            DNA_PREPROCESS.out.finalAln
            | set {dnaInputCRAM_single}

        }
        if (!params.skipStandard) {
            DNA_STANDARD(dnaInputCRAM)
        }
        if (!params.skipWGS) {
            DNA_WGS(dnaInputCRAM)
        }
        if (!params.skipQC) {
            DNA_QC(dnaInputCRAM_single)
        }
    
    }
    
    if (!params.skipRNA) {
        RNA_PREPROCESS(rnaInputFASTQ)

        //channels:
        RNA_PREPROCESS.out.star_out_cram_ch
        |map {meta,cram,crai -> tuple (meta,[cram,crai])}
        |set {rnaInputCRAM}

        RNA_PREPROCESS.out.arriba_input_bam
        |map {meta,bam,bai -> tuple (meta,[bam,bai])}
        |set {arribaBAM}

        rnaInputFASTQ
            .join(rnaInputCRAM)
            .join(RNA_PREPROCESS.out.sj_chimJunction)
        | set {trinity_splicing_input}

        RNA_PREPROCESS.out.isofox_input_cram
        |map {meta,cram,crai -> tuple (meta,[cram,crai])}
        |set {isofoxInputCRAM}
        // end, channels

        
        if (!params.skipExpression) {
            RNA_EXPRESSION(rnaInputCRAM, RNA_PREPROCESS.out.rsem_input_bam, isofoxInputCRAM)
                   
        }

        if (!params.skipSplicing) {
            RNA_SPLICING(trinity_splicing_input)
        }

        if (!params.skipFusion) {
            RNA_FUSION(rnaInputFASTQ, arribaBAM, RNA_PREPROCESS.out.chimeric_junctions_out)
        }
     
        /*        if (!params.skipQC) {
            RNA_QC(rnaInputCRAM)
        }
        */
    }

    // If default run (e.g. nothing skipped), run this after certain RNA and DNA processes complete:
    if (!params.skipRNA && !params.skipDNA && !params.skipExpression) {
        
        DNA_STANDARD.out.mutect2_tumorPASS
        |map {meta,vcf,idx -> tuple(meta, [vcf,idx])}
        |set {mutect2_tumorPASS_edit}

        
        DNA_STANDARD.out.mutect2_tumorPASS
            .join(RNA_EXPRESSION.out.rna_for_pcgr)
            .join(DNA_WGS.out.cna_for_pcgr)
        |map {meta,vcf,idx,rna,cna -> tuple(meta,[vcf,idx,rna,cna])}
        | set {pcgr_full_input}


        pcgr_v212_mutect2(pcgr_full_input)
    
        if (!params.skipQC) {
            def allOutputs = Channel.empty()

            allOutputs = allOutputs.mix(DNA_STANDARD.out.mutect2_snpEFF)    //meta, vcf
            allOutputs = allOutputs.mix(DNA_WGS.out.cna_for_pcgr)           //meta, cna
            allOutputs = allOutputs.mix(RNA_EXPRESSION.out.rna_for_pcgr)    //meta, rnaexpression(tpm)
            //allOutputs = allOutputs.mix(DNA_QC.out.collectWGSmetrics)       //meta, metrics.txt
            allOutputs = allOutputs.mix(DNA_QC.out.mosdepth)                //meta, mosdepth.dist.txt
            allOutputs = allOutputs.mix(DNA_QC.out.qualimap)                //meta, qualimap.html

            // Group by meta.id and run multiQC_ALL
            allOutputs
            |groupTuple
            |view
            |set {multiqcAllInput}

            multiQC_ALL(multiqcAllInput)
        }
    }
}



