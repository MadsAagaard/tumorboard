#!/usr/bin/env nextflow
nextflow.enable.dsl = 2

date=new Date().format( 'yyMMdd' )
user="$USER"
runID="${date}.${user}"




params.server                           =null
params.outdir                           ='tumorBoardWGS_results'
params.rundir                           ="${launchDir.baseName}" 
params.genome                           ="hg38" //default assembly is hg38, unless --genome is set!
params.rsem_strand                      ="reverse" // TO DO: INCLUDE STRANDEDNESS SELECTION!!!
params.gatk                             =null
params.suffix                           ="WG4_NGC"
// Unset parameters:
params.help                             =false
params.data                             =null
params.fastq                            =null
params.fastqInput                       =null
params.hg38v1                           =null
params.hg38v2                           =null
params.wes                              =null
// edit analysis steps
params.default                          =null
params.skipSplicing                     =null
params.skipFusion                       =null
params.skipExpression                   =null
params.skipVariants                     =null
params.skipTrim                         =null
params.skipQC                           =null
params.skipDNA                          =null
params.skipRNA                          =null
params.keepwork                         =null
params.nomail                           =null
params.skipSequenza                     =null
params.skipStandard                     =null
params.skipWGS                          =null
// skip or include individual analysis - unset parameters:
params.dupradar                         =null   // not run by default
params.qualimap                         =null   // not run by default
params.picard                           =null   // not run by default   

params.dataArchive                      ="/lnx01_data2/shared/dataArchive/"

def helpMessage() {
    log.info"""

    Generel info:
    Requires a samplesheet containing 5 columns in specific order (tab separated), without headerline:
    1) caseID, 2) NPN normal DNA, 3) NPN tumor DNA, 4) NPN tumor RNA, 5) PCGR tumor value

    Example samplesheet:

    johnDoe 112217976652	111184925465	111184925473    23

    The script will automatically look for inputdata (CRAM files for DNA data and fastq files for RNA-seq) at KG Vejle data archive.

    The user can point to a specific folder containing raw data (FastQ) using the --fastq option 
    This is only needed if input data only exists outside the data archive (e.g. if data are in personal folders).


    Main options:
      --help                print this help message

      --outdir              Select which folder to write output to.
                                Default: caseID from samplesheet

      --samplesheet         path to case samplesheet. Can contain multiple patients/cases (each case in a separate line). 

      --server              Select which server the analysis is performed on (lnx01 or other)
                                Default: null (only set this option if using lnx01 - defaults to all other servers)

      --fastq               Path to dir with fastq files
                                Default: data storage dirs KG Vejle archive

      --keepwork            keep the workfolder generated by the nextflow script.
                                Default: not set - removes the Work folder

      --nomail              Does not send a mail-message when completing a script
                                Default: not set - sends mail message if the user is mmaj or raspau and only if the script has been running longer than 20 minutes.


    QC options:
      --skipQC              Skip all QC steps except MultiQC
      --qualimap            Run qualimap BAMQC
                                Default: Do not run BAMQC (timeconsuming!)
      --dupradar            Run Dupradar (not available this version of the script)
                                Default: Do not run Dupradar (timeconsuming!)

    Analysis selection options (not set by default):
      --skipDNA             Do not run DNA analysis (only RNA)
      --skipRNA             Do not run RNA analysis (only DNA)  
      --skipWGS             Do not run analyses that require WGS data (e.g. HRD)
      --skipFusion          Do not call Fusions
      --skipAltSplicing     Do not call alternative splicevariants (e.g. exon skipping)
      --skipExpression      Do not analyse geneexpression (i.e. skip RSEM and isofox)

    """.stripIndent()
}
if (params.help) exit 0, helpMessage()



///////////////////////// SAMPLESHEET CHANNELS /////////////////////

// Samplesheet cols (fixed order)
// 0: CaseID, 1: NPN DNA blood, 2: NPN DNA Tumor, 3: NPN RNA tumor, 4: pcgr_tumor_code

////////////////////////////////////////////////////////////////////////////////


//////////// DEFAULT INPUT ///////////////////////

if (params.default) {
    inputFastq="${params.dataArchive}/lnx02/fastqStorage/novaRuns/**/*R{1,2}{_,.,-}*{fq,fastq}.gz";
    inputCram="${params.dataArchive}/lnx02/alignedData/hg38/novaRuns/**/*.cram"
    inputCrai="${params.dataArchive}/lnx02/alignedData/hg38/novaRuns/**/*.crai"
  //  inputFastq="/fast/data/tbtest/fastq/*.fastq.gz"
  //  inputCram="/fast/data/tbtest/cram/*.cram"
  //  inputCrai="/fast/data/tbtest/cram/*.crai"

    Channel.fromPath(inputCram, followLinks: true)
    |map { tuple(it.baseName,it) }
    |map {id,cram -> 
            (npn,datatype) =id.tokenize("_")
            meta=[npn:npn,datatype:datatype]
            [meta,cram]        
        }
    | set {cram_input }

    Channel.fromPath(inputCrai, followLinks: true)
    | map { tuple(it.baseName,it) }
    |map {id,crai -> 
            (npn,datatype) =id.tokenize("_")
            meta=[npn:npn,datatype:datatype]
             [meta,crai]         
        }
    |set {crai_input }

    cram_input.join(crai_input)
    |map { meta,cram,crai -> [meta.npn,meta,[cram,crai]] }
    | set {cram_final}

}

if (params.fastq) {
     inputFastq="${params.fastq}/*R{1,2}{_,.,-}*{fq,fastq}.gz";

}

if (!params.fastq) {
     inputFastq="${params.dataArchive}/**/*R{1,2}{_,.,-}*{fq,fastq}.gz";

}

if (params.fastq || params.fastqInput||params.default) {

    Channel.fromFilePairs(inputFastq, checkIfExists: true)
    | map { id, reads -> 
        (sample, ngstype)   = reads[0].baseName.tokenize("-")
       // (panel,subpanel)    = ngstype.tokenize("_")
        meta = [id:sample+"_"+ngstype, npn:sample, panel:ngstype]
        [meta.npn,meta, reads]
    }   
    | set {readsInput}

}

if (params.samplesheet) {
    channel.fromPath(params.samplesheet)
    | splitCsv(sep:'\t')
    |map { row -> 
            (caseID, npnNormal, npnTumorDNA, npnTumorRNA, pcgr) =tuple(row)
            //(normalID) =row[1]
        meta=[id:caseID,npnNormal:npnNormal,npnTumorDNA:npnTumorDNA,npnTumorRNA:npnTumorRNA,pcgr:pcgr]
        meta
        }
    | set {samplesheet_full}

    samplesheet_full
    | map { row -> 
            meta2=[row.npnNormal, row]}
        | set {samplesheetNormal}

    samplesheet_full
    | map { row -> 
            meta3=[row.npnTumorDNA, row]}
    | set {samplesheetTumorDNA}

    samplesheet_full
    | map { row -> 
            meta4=[row.npnTumorRNA, row]}
    | set {samplesheetTumorRNA}
}

if (params.samplesheet && (params.fastq||params.fastqInput)) {

    samplesheetNormal.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {normalDNA}

    samplesheetTumorDNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {tumorDNA}

    samplesheetTumorRNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {rnaInputFASTQ}

    normalDNA.concat(tumorDNA)
    |set {dnaInputFASTQ}    //meta, [fq1, fq2] pr sample
}

if (params.samplesheet && params.default) {


    samplesheetNormal.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {normalDNA}

    samplesheetTumorDNA.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }

    | set {tumorDNA}

    samplesheetTumorRNA.join(readsInput)
    |map {npn,metaSS,metaReads,reads -> [metaSS,reads] }
    | set {rnaInputFASTQ}

    normalDNA.join(tumorDNA)
    | map {meta,readsNormal,readsTumorDNA ->[meta,readsNormal+readsTumorDNA]}
    | set {dnaInputCRAM}
    //above meta: [id,npnNormal,npnTumorDNA, npnTumorRNA,pcgr]

    //per sample channels:
    samplesheetNormal.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaReads+[sampletype:"normal",id:metaSS.id],reads] }  // metaReads [npn, datatype (eg.WG4)]
    | set {normalDNA_single}

    samplesheetTumorDNA.join(cram_final)
    |map {npn,metaSS,metaReads,reads -> [metaReads+[sampletype:"tumor",id:metaSS.id],reads] }
    //[meta,reads]
    | set {tumorDNA_single}

    normalDNA_single.concat(tumorDNA_single)
    | set {dnaInputCRAM_single}
   // dnaInputCRAM_single.view() 
   // per sample (CRAM) ch: meta=[npn,datatype,sampletype,id] data=[cram,crai]


}


include {inputFiles_symlinks_cram;
        inputFiles_symlinks_fastq;
        multiQC_ALL;
        pcgr_v212_mutect2 } from "./modules/dnaModules.nf" 


include { isofox } from "./modules/rnaModules.nf" 

include {DNA_PREPROCESS;
         DNA_STANDARD;
         DNA_WGS;
         DNA_QC;
         RNA_PREPROCESS;
         RNA_EXPRESSION;
         RNA_SPLICING;
         RNA_FUSION;
         RNA_QC } from "./subworkflows/mainSubworkflows.nf" 



workflow {

    if (!params.skipDNA) {
        if(params.default) {
            inputFiles_symlinks_cram(dnaInputCRAM)
            // inputFiles_symlinks_fastq(rnaInputFASTQ)
        }
        if (params.fastq || params.fastqInput) {
            DNA_PREPROCESS(dnaInputFASTQ)
            DNA_PREPROCESS.out.finalAln //meta, cram, crai 
            |groupTuple
            |map {meta,cram,crai -> tuple(meta,[cram,crai])}
            |set {dnaInputCRAM}

            DNA_PREPROCESS.out.finalAln
            | set {dnaInputCRAM_single}

        }
        if (!params.skipStandard) {
            DNA_STANDARD(dnaInputCRAM)
        }
        if (!params.skipWGS) {
            DNA_WGS(dnaInputCRAM)
        }
        if (!params.skipQC) {
            DNA_QC(dnaInputCRAM_single)
        }
    
    }
    
    if (!params.skipRNA) {
        RNA_PREPROCESS(rnaInputFASTQ)

        //channels:
        RNA_PREPROCESS.out.star_out_cram_ch
        |map {meta,cram,crai -> tuple (meta,[cram,crai])}
        |set {rnaInputCRAM}

        RNA_PREPROCESS.out.arriba_input_bam
        |map {meta,bam,bai -> tuple (meta,[bam,bai])}
        |set {arribaBAM}

        rnaInputFASTQ
            .join(rnaInputCRAM)
            .join(RNA_PREPROCESS.out.sj_chimJunction)
        | set {trinity_splicing_input}

        RNA_PREPROCESS.out.isofox_input_cram
        |map {meta,cram,crai -> tuple (meta,[cram,crai])}
        |set {isofoxInputCRAM}
        // end, channels

        
        if (!params.skipExpression) {
            RNA_EXPRESSION(rnaInputCRAM, RNA_PREPROCESS.out.rsem_input_bam, isofoxInputCRAM)
                   
        }

        if (!params.skipSplicing) {
            RNA_SPLICING(trinity_splicing_input)
        }

        if (!params.skipFusion) {
            RNA_FUSION(rnaInputFASTQ, arribaBAM, RNA_PREPROCESS.out.chimeric_junctions_out)
        }
     
        /*        if (!params.skipQC) {
            RNA_QC(rnaInputCRAM)
        }
        */
    }

    // If default run (i.e. nothing skipped), run this after certain RNA and DNA processes complete:
    if (!params.skipRNA && !params.skipDNA && !params.skipExpression) {
        
        DNA_STANDARD.out.mutect2_tumorPASS
        |map {meta,vcf,idx -> tuple(meta, [vcf,idx])}
        |set {mutect2_tumorPASS_edit}

        
        DNA_STANDARD.out.mutect2_tumorPASS
            .join(RNA_EXPRESSION.out.rna_for_pcgr)
            .join(DNA_WGS.out.cna_for_pcgr)
        |map {meta,vcf,idx,rna,cna -> tuple(meta,[vcf,idx,rna,cna])}
        | set {pcgr_full_input}


        pcgr_v212_mutect2(pcgr_full_input)
    
        if (!params.skipQC) {
            def allOutputs = Channel.empty()

            allOutputs = allOutputs.mix(DNA_STANDARD.out.mutect2_snpEFF)    //meta, vcf
            allOutputs = allOutputs.mix(DNA_WGS.out.cna_for_pcgr)           //meta, cna
            allOutputs = allOutputs.mix(RNA_EXPRESSION.out.rna_for_pcgr)    //meta, rnaexpression(tpm)
            //allOutputs = allOutputs.mix(DNA_QC.out.collectWGSmetrics)       //meta, metrics.txt
            allOutputs = allOutputs.mix(DNA_QC.out.mosdepth)                //meta, mosdepth.dist.txt
            allOutputs = allOutputs.mix(DNA_QC.out.qualimap)                //meta, qualimap.html

            // Group by meta.id and run multiQC_ALL
            allOutputs
            |groupTuple
            |view
            |set {multiqcAllInput}

            multiQC_ALL(multiqcAllInput)
        }
    }
}



